# DP

## 参照
- https://kyopro-friends.hatenablog.com/entry/2019/01/12/230754
- https://twishort.com/Vntnc

## J
`dp[i, j, k]` : i, j, k をそれぞれ、残り 3 個、2 個、1 個の皿の数としたときの期待値

とすると、残り 0 個の皿の数は `n - i - j - k` であり、漸化式は、
```
dp[i, j, k] = 1 + ((n - i - j - k) * dp[i, j, k]
	+ i * dp[i - 1, j + 1, k]
	+ j * dp[i, j - 1, k + 1]
	+ k * dp[i, j, k - 1]) / n;
```

## M
`dp[i, j]` : 先頭の i 人で j 個の飴を分ける方法の数の、0 から j までの累積和

## N
2つの部分に分割してそれぞれのコストの最小値を求め、その2つの和の最小値。  
トーナメント方式。

## O
`dp[i, f]` : 男性 i までがペア済かつ女性のペア済のビット状態が f であるときの場合の数

高速化のため、ループ処理の中で値を更新する必要がない場合はブロック (continue) します。

## T
`dp[i, j]` : 0～i の順列で、末尾が j であるものの個数

- 配る DP の場合、いもす法を使う
- 貰う DP の場合、累積和を使う

## Y
はじめ、壁が存在しない状態で各マスへの経路の数を考えます。  
2 点の座標の差を `(x, y)` とすると、2点間の経路の数は `x+yCx`。

壁が存在することにより、そこから右下側にあるすべてのマスについて `x+yCx` だけ減ります。
- i, j の昇順に処理すればよい
- また、壁のマスおよび `(H, W)` への経路の数のみ保持すればよい
